import "@fluencelabs/aqua-lib/builtin.aqua"
import "deals.aqua"
import "services.aqua"
import "@fluencelabs/registry/subnetwork.aqua"
import Registry, Record from "@fluencelabs/registry/registry-service.aqua"
import "@fluencelabs/spell/spell_service.aqua"


export randomLoadBalancingEth, roundRobinEth, Counter, Logger

data QuorumResult:
  value: string
  results: []JsonString
  error: string

service Logger("logger"):
  log(s: []string)
  logCall(s: string)
  logWorker(w: Record)

service NumOp("op"):
  identity(n: u64) -> i64

service Counter("counter"):
  incrementAndReturn() -> u32

service QuorumChecker("quorum"):
  check(results: []JsonString, minResults: u32) -> QuorumResult

func empty() -> JsonString:
  <- JsonString(value = "", success = true, error = "")

func call(uri: string, method: string, jsonArgs: []string, serviceId: string) -> JsonString:
  EthRpc serviceId
  on HOST_PEER_ID:
    res <- EthRpc.eth_call(uri, method, jsonArgs)
  <- res

func randomLoadBalancing(uris: []string, method: string, jsonArgs: []string, serviceId: string, callFunc: string, string, []string, string -> JsonString) -> JsonString:
  on INIT_PEER_ID:
    time <- NumOp.identity(Peer.timestamp_sec())
    providerNumber = time % uris.length
    Logger.logCall(uris[providerNumber])
  <- callFunc(uris[providerNumber], method, jsonArgs, serviceId)

func randomLoadBalancingEth(uris: []string, method: string, jsonArgs: []string, serviceId: string) -> JsonString:
  <- randomLoadBalancing(uris, method, jsonArgs, serviceId, call)

func roundRobin(uris: []string, method: string, jsonArgs: []string, serviceId: string, counterServiceId: string, counterPeerId: string, callFunc: string, string, []string, string -> JsonString) -> JsonString:
  on counterPeerId:
    Counter counterServiceId
    requestNumber <- Counter.incrementAndReturn()
  on INIT_PEER_ID:
    providerNumber = requestNumber % uris.length
    Logger.logCall(uris[providerNumber])
  <- callFunc(uris[providerNumber], method, jsonArgs, serviceId)

func roundRobinEth(uris: []string, method: string, jsonArgs: []string, serviceId: string, counterServiceId: string, counterPeerId: string) -> JsonString:
  <- roundRobin(uris, method, jsonArgs, serviceId, counterServiceId, counterPeerId, call)

func quorum(uris: []string, quorumNumber: u32, timeout: u32, method: string, jsonArgs: []string, serviceId: string, quorumServiceId: string, quorumPeerId: string, 
    callFunc: string, string, []string, string -> JsonString) -> QuorumResult:
  results: *JsonString
  on INIT_PEER_ID:
    for uri <- uris par:
      results <- callFunc(uri, method, jsonArgs, serviceId)
  join results[uris.length - 1]
  par Peer.timeout(timeout, "") 
  on quorumPeerId:
    Counter quorumServiceId
    quorumResult <- QuorumChecker.check(results, quorumNumber)
  <- quorumResult

func quorumEth(uris: []string, quorumNumber: u32, timeout: u32, method: string, jsonArgs: []string, serviceId: string, quorumServiceId: string, quorumPeerId: string) -> QuorumResult:
  <- quorum(uris, quorumNumber, timeout, method, jsonArgs, serviceId, quorumServiceId, quorumPeerId, call)

func withSubnets(uris: []string, method: string, jsonArgs: []string) -> JsonString:
  workersInfo <- getWorkersInfo()
  dealId = workersInfo.defaultWorker.dealId    
  on HOST_PEER_ID:
    workersOp <- resolveSubnetwork(dealId)
    workers = workersOp!
    workersNum = workers.length
    -- choose worker randomly
    timeW <- NumOp.identity(Peer.timestamp_sec())
    workerNumber = timeW % workers.length
    worker = workers[workerNumber] 
    on worker.metadata.peer_id via worker.metadata.relay_id:
      -- choose provider randomly
      timeP <- NumOp.identity(Peer.timestamp_sec())
      providerNumber = timeW % uris.length
      result <- EthRpc.eth_call(uris[providerNumber], method, jsonArgs)
  Logger.logWorker(worker)
  Logger.logCall(uris[providerNumber])
  <- result